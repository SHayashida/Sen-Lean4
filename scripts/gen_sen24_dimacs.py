#!/usr/bin/env python3
"""
Generate a DIMACS CNF encoding of the Sen base case (n=2 voters, m=4 alternatives).

This writes ONLY CNF (no Lean), so Lean can remain small and verify UNSAT via LRAT:
  - CNF:  Certificates/sen24.cnf
  - LRAT: Certificates/sen24.lrat  (to be generated by an external SAT solver)
  - Manifest: Certificates/sen24.manifest.json (schema + counts for audits)
"""

from __future__ import annotations

import argparse
import hashlib
import itertools
import json
from pathlib import Path


ALT = [0, 1, 2, 3]
PAIRS = [(a, b) for a in ALT for b in ALT if a != b]  # 12 ordered pairs
PAIR_IDX = {(a, b): i for i, (a, b) in enumerate(PAIRS)}

N_RANKINGS = 24
N_PROFILES = N_RANKINGS * N_RANKINGS  # 576
N_PAIRS = len(PAIRS)  # 12
N_P_VARS = N_PROFILES * N_PAIRS  # 6912

# MINLIB selector vars (witnesses):
# - 12 selectors for voter0 decisive pair
# - 12 selectors for voter1 decisive pair
N_SEL = 2 * N_PAIRS
N_VARS = N_P_VARS + N_SEL  # 6936


def var_p(p: int, a: int, b: int) -> int:
    """DIMACS var number (1-based) for P[p,a,b]."""
    return p * N_PAIRS + PAIR_IDX[(a, b)] + 1


def var_sel0(a: int, b: int) -> int:
    """DIMACS var number (1-based) for 'voter0 decisive on (a,b)' selector."""
    return N_P_VARS + PAIR_IDX[(a, b)] + 1


def var_sel1(a: int, b: int) -> int:
    """DIMACS var number (1-based) for 'voter1 decisive on (a,b)' selector."""
    return N_P_VARS + N_PAIRS + PAIR_IDX[(a, b)] + 1


def all_rankings() -> list[tuple[int, int, int, int]]:
    return list(itertools.permutations(ALT, 4))


def pos_map(perm: tuple[int, int, int, int]) -> dict[int, int]:
    return {a: i for i, a in enumerate(perm)}


def emit_dimacs(path: Path) -> dict[str, int]:
    rankings = all_rankings()
    assert len(rankings) == N_RANKINGS
    pos = [pos_map(r) for r in rankings]

    # Profiles: (r0_idx, r1_idx), index p = r0_idx * 24 + r1_idx
    profiles = [(i, j) for i in range(N_RANKINGS) for j in range(N_RANKINGS)]
    assert len(profiles) == N_PROFILES

    clauses: list[list[int]] = []
    category_counts: dict[str, int] = {}

    # 1) ASYMM: for each profile, for each ordered pair (a,b), forbid both directions.
    # Note this contains duplicates: the clause for (a,b) is identical to that for (b,a).
    # We keep the full ordered-pair loop because it matches the audited spec.
    start = len(clauses)
    for p in range(N_PROFILES):
        for a, b in PAIRS:
            clauses.append([-var_p(p, a, b), -var_p(p, b, a)])
    category_counts["asymm"] = len(clauses) - start

    # 2) UN: if both voters prefer a>b then enforce P[p,a,b] (unit clause).
    start = len(clauses)
    for p, (r0, r1) in enumerate(profiles):
        pos0 = pos[r0]
        pos1 = pos[r1]
        for a, b in PAIRS:
            if pos0[a] < pos0[b] and pos1[a] < pos1[b]:
                clauses.append([var_p(p, a, b)])
    category_counts["un"] = len(clauses) - start

    # 3) MINLIB: existential decisive pairs via selectors.
    # (OR sel0_xy) ∧ (OR sel1_xy)
    start = len(clauses)
    clauses.append([var_sel0(a, b) for (a, b) in PAIRS])
    clauses.append([var_sel1(a, b) for (a, b) in PAIRS])

    # sel_i(x,y) → for all profiles p: (if voter i prefers x>y then P[p,x,y] else P[p,y,x])
    for p, (r0, r1) in enumerate(profiles):
        pos0 = pos[r0]
        pos1 = pos[r1]
        for a, b in PAIRS:
            lit0 = var_p(p, a, b) if pos0[a] < pos0[b] else var_p(p, b, a)
            clauses.append([-var_sel0(a, b), lit0])
            lit1 = var_p(p, a, b) if pos1[a] < pos1[b] else var_p(p, b, a)
            clauses.append([-var_sel1(a, b), lit1])
    category_counts["minlib"] = len(clauses) - start

    # 4) SocialAcyclic on 4 alternatives: forbid all directed 3-cycles and 4-cycles.
    triples = [(a, b, c) for a in ALT for b in ALT for c in ALT if len({a, b, c}) == 3]
    quads = list(itertools.permutations(ALT, 4))
    assert len(triples) == 24
    assert len(quads) == 24

    start = len(clauses)
    for p in range(N_PROFILES):
        for a, b, c in triples:
            clauses.append([-var_p(p, a, b), -var_p(p, b, c), -var_p(p, c, a)])
    category_counts["no_cycle3"] = len(clauses) - start

    start = len(clauses)
    for p in range(N_PROFILES):
        for a, b, c, d in quads:
            clauses.append([-var_p(p, a, b), -var_p(p, b, c), -var_p(p, c, d), -var_p(p, d, a)])
    category_counts["no_cycle4"] = len(clauses) - start

    # Write DIMACS with no comments (Mathlib parser assumes comments are stripped).
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        f.write(f"p cnf {N_VARS} {len(clauses)}\n")
        for cl in clauses:
            f.write(" ".join(str(x) for x in cl) + " 0\n")
    return category_counts


def write_manifest(path: Path, cnf_path: Path, category_counts: dict[str, int]) -> None:
    cnf_bytes = cnf_path.read_bytes()
    cnf_sha256 = hashlib.sha256(cnf_bytes).hexdigest()

    aux_start = N_P_VARS + 1
    aux_end = N_VARS
    manifest = {
        "encoding": "sen24",
        "alts": ALT,
        "pair_order": [list(x) for x in PAIRS],
        "ranking_order": "itertools.permutations(ALT,4) lex",
        "profile_order": "p = r0*24 + r1 (r0 major)",
        "nranks": N_RANKINGS,
        "nprofiles": N_PROFILES,
        "npairs": N_PAIRS,
        "n_p_vars": N_P_VARS,
        "nvars": N_VARS,
        "nclauses": sum(category_counts.values()),
        "category_counts": category_counts,
        "minlib": {"mode": "selectors_v1"},
        "p_var_range": [1, N_P_VARS],
        "aux_var_range": [aux_start, aux_end],
        "cnf_sha256": cnf_sha256,
    }
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(manifest, indent=2, sort_keys=True) + "\n", encoding="utf-8")


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--out",
        type=Path,
        default=Path("Certificates/sen24.cnf"),
        help="Output DIMACS CNF path (default: Certificates/sen24.cnf)",
    )
    ap.add_argument(
        "--manifest-out",
        type=Path,
        default=Path("Certificates/sen24.manifest.json"),
        help="Output JSON manifest path (default: Certificates/sen24.manifest.json)",
    )
    args = ap.parse_args()
    category_counts = emit_dimacs(args.out)
    write_manifest(args.manifest_out, args.out, category_counts)
    print(f"Wrote {args.out}")
    print(f"Wrote {args.manifest_out}")


if __name__ == "__main__":
    main()
